diff --git a/node_modules/protobufjs/dist/protobuf.js b/node_modules/protobufjs/dist/protobuf.js
index 44f4d9c..08ae587 100644
--- a/node_modules/protobufjs/dist/protobuf.js
+++ b/node_modules/protobufjs/dist/protobuf.js
@@ -19,7 +19,7 @@
  * Released under the Apache License, Version 2.0
  * see: https://github.com/dcodeIO/protobuf.js for details
  */
-(function(global, factory) {
+(function (global, factory) {
 
     /* AMD */ if (typeof define === 'function' && define["amd"])
         define(["bytebuffer"], factory);
@@ -28,7 +28,7 @@
     /* Global */ else
         (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
 
-})(this, function(ByteBuffer, isCommonJS) {
+})(this, function (ByteBuffer, isCommonJS) {
     "use strict";
 
     /**
@@ -198,7 +198,7 @@
         "fixed64": {
             name: "fixed64",
             wireType: ProtoBuf.WIRE_TYPES.BITS64,
-            defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
+            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
         },
         "sfixed64": {
             name: "sfixed64",
@@ -293,7 +293,7 @@
      * @alias ProtoBuf.Util
      * @expose
      */
-    ProtoBuf.Util = (function() {
+    ProtoBuf.Util = (function () {
         "use strict";
 
         /**
@@ -310,7 +310,7 @@
          * @expose
          */
         Util.IS_NODE = !!(
-            typeof process === 'object' && process+'' === '[object process]' && !process['browser']
+            typeof process === 'object' && process + '' === '[object process]' && !process['browser']
         );
 
         /**
@@ -319,17 +319,17 @@
          * @throws {Error} If XMLHttpRequest is not supported
          * @expose
          */
-        Util.XHR = function() {
+        Util.XHR = function () {
             // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
             var XMLHttpFactories = [
-                function () {return new XMLHttpRequest()},
-                function () {return new ActiveXObject("Msxml2.XMLHTTP")},
-                function () {return new ActiveXObject("Msxml3.XMLHTTP")},
-                function () {return new ActiveXObject("Microsoft.XMLHTTP")}
+                function () { return new XMLHttpRequest() },
+                function () { return new ActiveXObject("Msxml2.XMLHTTP") },
+                function () { return new ActiveXObject("Msxml3.XMLHTTP") },
+                function () { return new ActiveXObject("Microsoft.XMLHTTP") }
             ];
             /** @type {?XMLHttpRequest} */
             var xhr = null;
-            for (var i=0;i<XMLHttpFactories.length;i++) {
+            for (var i = 0; i < XMLHttpFactories.length; i++) {
                 try { xhr = XMLHttpFactories[i](); }
                 catch (e) { continue; }
                 break;
@@ -347,17 +347,17 @@
          * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
          * @expose
          */
-        Util.fetch = function(path, callback) {
+        Util.fetch = function (path, callback) {
             if (callback && typeof callback != 'function')
                 callback = null;
             if (Util.IS_NODE) {
                 var fs = require("fs");
                 if (callback) {
-                    fs.readFile(path, function(err, data) {
+                    fs.readFile(path, function (err, data) {
                         if (err)
                             callback(null);
                         else
-                            callback(""+data);
+                            callback("" + data);
                     });
                 } else
                     try {
@@ -372,7 +372,7 @@
                 xhr.setRequestHeader('Accept', 'text/plain');
                 if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');
                 if (callback) {
-                    xhr.onreadystatechange = function() {
+                    xhr.onreadystatechange = function () {
                         if (xhr.readyState != 4) return;
                         if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                             callback(xhr.responseText);
@@ -397,7 +397,7 @@
          * @returns {string}
          * @expose
          */
-        Util.toCamelCase = function(str) {
+        Util.toCamelCase = function (str) {
             return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
                 return $1.toUpperCase();
             });
@@ -475,7 +475,7 @@
      * @alias ProtoBuf.DotProto
      * @expose
      */
-    ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
+    ProtoBuf.DotProto = (function (ProtoBuf, Lang) {
         "use strict";
 
         /**
@@ -492,14 +492,14 @@
          * @param {string} proto Proto to tokenize
          * @constructor
          */
-        var Tokenizer = function(proto) {
+        var Tokenizer = function (proto) {
 
             /**
              * Source to parse.
              * @type {string}
              * @expose
              */
-            this.source = proto+"";
+            this.source = proto + "";
 
             /**
              * Current index.
@@ -541,7 +541,7 @@
          * @return {string}
          * @private
          */
-        TokenizerPrototype._readString = function() {
+        TokenizerPrototype._readString = function () {
             var re = this._stringOpen === '"'
                 ? Lang.STRING_DQ
                 : Lang.STRING_SQ;
@@ -560,7 +560,7 @@
          * @return {?string} Token or `null` on EOF
          * @expose
          */
-        TokenizerPrototype.next = function() {
+        TokenizerPrototype.next = function () {
             if (this.stack.length > 0)
                 return this.stack.shift();
             if (this.index >= this.source.length)
@@ -616,7 +616,7 @@
             Lang.DELIM.lastIndex = 0;
             var delim = Lang.DELIM.test(this.source.charAt(end++));
             if (!delim)
-                while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
+                while (end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))
                     ++end;
             var token = this.source.substring(this.index, this.index = end);
             if (token === '"' || token === "'")
@@ -629,7 +629,7 @@
          * @return {?string} Token or `null` on EOF
          * @expose
          */
-        TokenizerPrototype.peek = function() {
+        TokenizerPrototype.peek = function () {
             if (this.stack.length === 0) {
                 var token = this.next();
                 if (token === null)
@@ -644,10 +644,10 @@
          * @param {string} expected Expected token
          * @throws {Error} If the actual token differs
          */
-        TokenizerPrototype.skip = function(expected) {
+        TokenizerPrototype.skip = function (expected) {
             var actual = this.next();
             if (actual !== expected)
-                throw Error("illegal '"+actual+"', '"+expected+"' expected");
+                throw Error("illegal '" + actual + "', '" + expected + "' expected");
         };
 
         /**
@@ -655,7 +655,7 @@
          * @param {string} expected Expected optional token
          * @returns {boolean} `true` if the token exists
          */
-        TokenizerPrototype.omit = function(expected) {
+        TokenizerPrototype.omit = function (expected) {
             if (this.peek() === expected) {
                 this.next();
                 return true;
@@ -668,8 +668,8 @@
          * @return {string} String representation as of "Tokenizer(index/length)"
          * @expose
          */
-        TokenizerPrototype.toString = function() {
-            return "Tokenizer ("+this.index+"/"+this.source.length+" at line "+this.line+")";
+        TokenizerPrototype.toString = function () {
+            return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")";
         };
 
         /**
@@ -685,7 +685,7 @@
          * @param {string} source Source
          * @constructor
          */
-        var Parser = function(source) {
+        var Parser = function (source) {
 
             /**
              * Tokenizer.
@@ -713,7 +713,7 @@
          * @throws {Error} If the source cannot be parsed
          * @expose
          */
-        ParserPrototype.parse = function() {
+        ParserPrototype.parse = function () {
             var topLevel = {
                 "name": "[ROOT]", // temporary
                 "package": null,
@@ -780,7 +780,7 @@
                     }
                 }
             } catch (e) {
-                e.message = "Parse error at line "+this.tn.line+": " + e.message;
+                e.message = "Parse error at line " + this.tn.line + ": " + e.message;
                 throw e;
             }
             delete topLevel["name"];
@@ -793,7 +793,7 @@
          * @throws {Error} If the source cannot be parsed
          * @expose
          */
-        Parser.parse = function(source) {
+        Parser.parse = function (source) {
             return new Parser(source).parse();
         };
 
@@ -821,7 +821,7 @@
                 id = parseInt(value.substring(1), 8);
             else
                 throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
-            id = (sign*id)|0; // Force to 32bit
+            id = (sign * id) | 0; // Force to 32bit
             if (!mayBeNegative && id < 0)
                 throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
             return id;
@@ -861,14 +861,14 @@
          * @returns {string}
          * @private
          */
-        ParserPrototype._readString = function() {
+        ParserPrototype._readString = function () {
             var value = "",
                 token,
                 delim;
             do {
                 delim = this.tn.next();
                 if (delim !== "'" && delim !== '"')
-                    throw Error("illegal string delimiter: "+delim);
+                    throw Error("illegal string delimiter: " + delim);
                 value += this.tn.next();
                 this.tn.skip(delim);
                 token = this.tn.peek();
@@ -882,7 +882,7 @@
          * @returns {number|boolean|string}
          * @private
          */
-        ParserPrototype._readValue = function(mayBeTypeRef) {
+        ParserPrototype._readValue = function (mayBeTypeRef) {
             var token = this.tn.peek(),
                 value;
             if (token === '"' || token === "'")
@@ -894,7 +894,7 @@
                 return (token.toLowerCase() === 'true');
             if (mayBeTypeRef && Lang.TYPEREF.test(token))
                 return token;
-            throw Error("illegal value: "+token);
+            throw Error("illegal value: " + token);
 
         };
 
@@ -906,7 +906,7 @@
          * @param {boolean=} isList
          * @private
          */
-        ParserPrototype._parseOption = function(parent, isList) {
+        ParserPrototype._parseOption = function (parent, isList) {
             var token = this.tn.next(),
                 custom = false;
             if (token === '(') {
@@ -916,11 +916,11 @@
             if (!Lang.TYPEREF.test(token))
                 // we can allow options of the form google.protobuf.* since they will just get ignored anyways
                 // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
-                    throw Error("illegal option name: "+token);
+                throw Error("illegal option name: " + token);
             var name = token;
             if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
                 this.tn.skip(')');
-                name = '('+name+')';
+                name = '(' + name + ')';
                 token = this.tn.peek();
                 if (Lang.FQTYPEREF.test(token)) {
                     name += token;
@@ -945,7 +945,7 @@
                 options[name] = value;
             else {
                 if (!Array.isArray(options[name]))
-                    options[name] = [ options[name] ];
+                    options[name] = [options[name]];
                 options[name].push(value);
             }
         }
@@ -956,7 +956,7 @@
          * @param {string} name
          * @private
          */
-        ParserPrototype._parseOptionValue = function(parent, name) {
+        ParserPrototype._parseOptionValue = function (parent, name) {
             var token = this.tn.peek();
             if (token !== '{') { // Plain value
                 setOption(parent["options"], name, this._readValue(true));
@@ -978,10 +978,10 @@
          * @param {!Object} parent Parent definition
          * @private
          */
-        ParserPrototype._parseService = function(parent) {
+        ParserPrototype._parseService = function (parent) {
             var token = this.tn.next();
             if (!Lang.NAME.test(token))
-                throw Error("illegal service name at line "+this.tn.line+": "+token);
+                throw Error("illegal service name at line " + this.tn.line + ": " + token);
             var name = token;
             var svc = {
                 "name": name,
@@ -995,7 +995,7 @@
                 else if (token === 'rpc')
                     this._parseServiceRPC(svc);
                 else
-                    throw Error("illegal service token: "+token);
+                    throw Error("illegal service token: " + token);
             }
             this.tn.omit(";");
             parent["services"].push(svc);
@@ -1006,11 +1006,11 @@
          * @param {!Object} svc Service definition
          * @private
          */
-        ParserPrototype._parseServiceRPC = function(svc) {
+        ParserPrototype._parseServiceRPC = function (svc) {
             var type = "rpc",
                 token = this.tn.next();
             if (!Lang.NAME.test(token))
-                throw Error("illegal rpc service method name: "+token);
+                throw Error("illegal rpc service method name: " + token);
             var name = token;
             var method = {
                 "request": null,
@@ -1022,21 +1022,21 @@
             this.tn.skip("(");
             token = this.tn.next();
             if (token.toLowerCase() === "stream") {
-              method["request_stream"] = true;
-              token = this.tn.next();
+                method["request_stream"] = true;
+                token = this.tn.next();
             }
             if (!Lang.TYPEREF.test(token))
-                throw Error("illegal rpc service request type: "+token);
+                throw Error("illegal rpc service request type: " + token);
             method["request"] = token;
             this.tn.skip(")");
             token = this.tn.next();
             if (token.toLowerCase() !== "returns")
-                throw Error("illegal rpc service request type delimiter: "+token);
+                throw Error("illegal rpc service request type delimiter: " + token);
             this.tn.skip("(");
             token = this.tn.next();
             if (token.toLowerCase() === "stream") {
-              method["response_stream"] = true;
-              token = this.tn.next();
+                method["response_stream"] = true;
+                token = this.tn.next();
             }
             method["response"] = token;
             this.tn.skip(")");
@@ -1064,7 +1064,7 @@
          * @returns {!Object}
          * @private
          */
-        ParserPrototype._parseMessage = function(parent, fld) {
+        ParserPrototype._parseMessage = function (parent, fld) {
             var isGroup = !!fld,
                 token = this.tn.next();
             var msg = {
@@ -1078,7 +1078,7 @@
                 // "extensions": undefined
             };
             if (!Lang.NAME.test(token))
-                throw Error("illegal "+(isGroup ? "group" : "message")+" name: "+token);
+                throw Error("illegal " + (isGroup ? "group" : "message") + " name: " + token);
             msg["name"] = token;
             if (isGroup) {
                 this.tn.skip("=");
@@ -1114,10 +1114,10 @@
                     this._parseExtend(msg);
                 else if (Lang.TYPEREF.test(token)) {
                     if (!this.proto3)
-                        throw Error("illegal field rule: "+token);
+                        throw Error("illegal field rule: " + token);
                     this._parseMessageField(msg, "optional", token);
                 } else
-                    throw Error("illegal message token: "+token);
+                    throw Error("illegal message token: " + token);
             }
             this.tn.omit(";");
             parent["messages"].push(msg);
@@ -1128,7 +1128,7 @@
          * Parses an ignored statement.
          * @private
          */
-        ParserPrototype._parseIgnored = function() {
+        ParserPrototype._parseIgnored = function () {
             while (this.tn.peek() !== ';')
                 this.tn.next();
             this.tn.skip(";");
@@ -1142,9 +1142,9 @@
          * @returns {!Object} Field descriptor
          * @private
          */
-        ParserPrototype._parseMessageField = function(msg, rule, type) {
+        ParserPrototype._parseMessageField = function (msg, rule, type) {
             if (!Lang.RULE.test(rule))
-                throw Error("illegal message field rule: "+rule);
+                throw Error("illegal message field rule: " + rule);
             var fld = {
                 "rule": rule,
                 "type": "",
@@ -1190,7 +1190,7 @@
                     // converted to lower-case so that it does not conflict with the former)."
                     var grp = this._parseMessage(msg, fld);
                     if (!/^[A-Z]/.test(grp["name"]))
-                        throw Error('illegal group name: '+grp["name"]);
+                        throw Error('illegal group name: ' + grp["name"]);
                     fld["type"] = grp["name"];
                     fld["name"] = grp["name"].toLowerCase();
                     this.tn.omit(";");
@@ -1222,10 +1222,10 @@
          * @param {!Object} msg Message definition
          * @private
          */
-        ParserPrototype._parseMessageOneOf = function(msg) {
+        ParserPrototype._parseMessageOneOf = function (msg) {
             var token = this.tn.next();
             if (!Lang.NAME.test(token))
-                throw Error("illegal oneof name: "+token);
+                throw Error("illegal oneof name: " + token);
             var name = token,
                 fld;
             var fields = [];
@@ -1244,7 +1244,7 @@
          * @param {!Object} fld Field definition
          * @private
          */
-        ParserPrototype._parseFieldOptions = function(fld) {
+        ParserPrototype._parseFieldOptions = function (fld) {
             this.tn.skip("[");
             var token,
                 first = true;
@@ -1262,7 +1262,7 @@
          * @param {!Object} msg Message definition
          * @private
          */
-        ParserPrototype._parseEnum = function(msg) {
+        ParserPrototype._parseEnum = function (msg) {
             var enm = {
                 "name": "",
                 "values": [],
@@ -1270,26 +1270,32 @@
             };
             var token = this.tn.next();
             if (!Lang.NAME.test(token))
-                throw Error("illegal name: "+token);
+                throw Error("illegal name: " + token);
             enm["name"] = token;
             this.tn.skip("{");
             while ((token = this.tn.next()) !== '}') {
-                if (token === "option")
-                    this._parseOption(enm);
-                else {
-                    if (!Lang.NAME.test(token))
-                        throw Error("illegal name: "+token);
-                    this.tn.skip("=");
-                    var val = {
-                        "name": token,
-                        "id": mkId(this.tn.next(), true)
-                    };
-                    token = this.tn.peek();
-                    if (token === "[")
-                        this._parseFieldOptions({ "options": {} });
-                    this.tn.skip(";");
-                    enm["values"].push(val);
+                switch (token) {
+                    case "option":
+                        this._parseOption(enm);
+                        break;
+                    case "reserved":
+                        this._parseIgnored();
+                        break;
+                    default:
+                        if (!Lang.NAME.test(token))
+                            throw Error("illegal name: " + token);
+                        this.tn.skip("=");
+                        var val = {
+                            "name": token,
+                            "id": mkId(this.tn.next(), true)
+                        };
+                        token = this.tn.peek();
+                        if (token === "[")
+                            this._parseFieldOptions({ "options": {} });
+                        this.tn.skip(";");
+                        enm["values"].push(val);
                 }
+
             }
             this.tn.omit(";");
             msg["enums"].push(enm);
@@ -1300,7 +1306,7 @@
          * @returns {!Array.<!Array.<number>>}
          * @private
          */
-        ParserPrototype._parseExtensionRanges = function() {
+        ParserPrototype._parseExtensionRanges = function () {
             var ranges = [];
             var token,
                 range,
@@ -1340,10 +1346,10 @@
          * @param {!Object} parent Parent object
          * @private
          */
-        ParserPrototype._parseExtend = function(parent) {
+        ParserPrototype._parseExtend = function (parent) {
             var token = this.tn.next();
             if (!Lang.TYPEREF.test(token))
-                throw Error("illegal extend reference: "+token);
+                throw Error("illegal extend reference: " + token);
             var ext = {
                 "ref": token,
                 "fields": []
@@ -1354,10 +1360,10 @@
                     this._parseMessageField(ext, token);
                 else if (Lang.TYPEREF.test(token)) {
                     if (!this.proto3)
-                        throw Error("illegal field rule: "+token);
+                        throw Error("illegal field rule: " + token);
                     this._parseMessageField(ext, "optional", token);
                 } else
-                    throw Error("illegal extend token: "+token);
+                    throw Error("illegal extend token: " + token);
             }
             this.tn.omit(";");
             parent["messages"].push(ext);
@@ -1370,8 +1376,8 @@
          * Returns a string representation of this parser.
          * @returns {string}
          */
-        ParserPrototype.toString = function() {
-            return "Parser at line "+this.tn.line;
+        ParserPrototype.toString = function () {
+            return "Parser at line " + this.tn.line;
         };
 
         /**
@@ -1388,7 +1394,7 @@
      * @alias ProtoBuf.Reflect
      * @expose
      */
-    ProtoBuf.Reflect = (function(ProtoBuf) {
+    ProtoBuf.Reflect = (function (ProtoBuf) {
         "use strict";
 
         /**
@@ -1407,7 +1413,7 @@
          * @param {?ProtoBuf.Reflect.T} parent Parent object
          * @param {string} name Object name
          */
-        var T = function(builder, parent, name) {
+        var T = function (builder, parent, name) {
 
             /**
              * Builder reference.
@@ -1449,14 +1455,14 @@
          * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
          * @expose
          */
-        TPrototype.fqn = function() {
+        TPrototype.fqn = function () {
             var name = this.name,
                 ptr = this;
             do {
                 ptr = ptr.parent;
                 if (ptr == null)
                     break;
-                name = ptr.name+"."+name;
+                name = ptr.name + "." + name;
             } while (true);
             return name;
         };
@@ -1467,7 +1473,7 @@
          * @return String representation
          * @expose
          */
-        TPrototype.toString = function(includeClass) {
+        TPrototype.toString = function (includeClass) {
             return (includeClass ? this.className + " " : "") + this.fqn();
         };
 
@@ -1476,8 +1482,8 @@
          * @throws {Error} If this type cannot be built directly
          * @expose
          */
-        TPrototype.build = function() {
-            throw Error(this.toString(true)+" cannot be built directly");
+        TPrototype.build = function () {
+            throw Error(this.toString(true) + " cannot be built directly");
         };
 
         /**
@@ -1497,7 +1503,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.T
          */
-        var Namespace = function(builder, parent, name, options, syntax) {
+        var Namespace = function (builder, parent, name, options, syntax) {
             T.call(this, builder, parent, name);
 
             /**
@@ -1536,12 +1542,12 @@
          * @return {Array.<ProtoBuf.Reflect.T>}
          * @expose
          */
-        NamespacePrototype.getChildren = function(type) {
+        NamespacePrototype.getChildren = function (type) {
             type = type || null;
             if (type == null)
                 return this.children.slice();
             var children = [];
-            for (var i=0, k=this.children.length; i<k; ++i)
+            for (var i = 0, k = this.children.length; i < k; ++i)
                 if (this.children[i] instanceof type)
                     children.push(this.children[i]);
             return children;
@@ -1553,7 +1559,7 @@
          * @throws {Error} If the child cannot be added (duplicate)
          * @expose
          */
-        NamespacePrototype.addChild = function(child) {
+        NamespacePrototype.addChild = function (child) {
             var other;
             if (other = this.getChild(child.name)) {
                 // Try to revert camelcase transformation on collision
@@ -1562,7 +1568,7 @@
                 else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)
                     child.name = child.originalName;
                 else
-                    throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);
+                    throw Error("Duplicate name in namespace " + this.toString(true) + ": " + child.name);
             }
             this.children.push(child);
         };
@@ -1573,9 +1579,9 @@
          * @return {?ProtoBuf.Reflect.T} The child or null if not found
          * @expose
          */
-        NamespacePrototype.getChild = function(nameOrId) {
+        NamespacePrototype.getChild = function (nameOrId) {
             var key = typeof nameOrId === 'number' ? 'id' : 'name';
-            for (var i=0, k=this.children.length; i<k; ++i)
+            for (var i = 0, k = this.children.length; i < k; ++i)
                 if (this.children[i][key] === nameOrId)
                     return this.children[i];
             return null;
@@ -1588,7 +1594,7 @@
          * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
          * @expose
          */
-        NamespacePrototype.resolve = function(qn, excludeNonNamespace) {
+        NamespacePrototype.resolve = function (qn, excludeNonNamespace) {
             var part = typeof qn === 'string' ? qn.split(".") : qn,
                 ptr = this,
                 i = 0;
@@ -1626,14 +1632,14 @@
          * @returns {string} The shortest qualified name or, if there is none, the fqn
          * @expose
          */
-        NamespacePrototype.qn = function(t) {
+        NamespacePrototype.qn = function (t) {
             var part = [], ptr = t;
             do {
                 part.unshift(ptr.name);
                 ptr = ptr.parent;
             } while (ptr !== null);
-            for (var len=1; len <= part.length; len++) {
-                var qn = part.slice(part.length-len);
+            for (var len = 1; len <= part.length; len++) {
+                var qn = part.slice(part.length - len);
                 if (t === this.resolve(qn, t instanceof Reflect.Namespace))
                     return qn.join(".");
             }
@@ -1645,11 +1651,11 @@
          * @return {Object.<string,Function|Object>} Runtime namespace
          * @expose
          */
-        NamespacePrototype.build = function() {
+        NamespacePrototype.build = function () {
             /** @dict */
             var ns = {};
             var children = this.children;
-            for (var i=0, k=children.length, child; i<k; ++i) {
+            for (var i = 0, k = children.length, child; i < k; ++i) {
                 child = children[i];
                 if (child instanceof Namespace)
                     ns[child.name] = child.build();
@@ -1663,10 +1669,10 @@
          * Builds the namespace's '$options' property.
          * @return {Object.<string,*>}
          */
-        NamespacePrototype.buildOpt = function() {
+        NamespacePrototype.buildOpt = function () {
             var opt = {},
                 keys = Object.keys(this.options);
-            for (var i=0, k=keys.length; i<k; ++i) {
+            for (var i = 0, k = keys.length; i < k; ++i) {
                 var key = keys[i],
                     val = this.options[keys[i]];
                 // TODO: Options are not resolved, yet.
@@ -1684,7 +1690,7 @@
          * @param {string=} name Returns the option value if specified, otherwise all options are returned.
          * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
          */
-        NamespacePrototype.getOption = function(name) {
+        NamespacePrototype.getOption = function (name) {
             if (typeof name === 'undefined')
                 return this.options;
             return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
@@ -1717,7 +1723,7 @@
          * messages)
          * @constructor
          */
-        var Element = function(type, resolvedType, isMapKey, syntax, name) {
+        var Element = function (type, resolvedType, isMapKey, syntax, name) {
 
             /**
              * Element type, as a string (e.g., int32).
@@ -1765,7 +1771,7 @@
             if (typeof type === 'string')
                 type = ProtoBuf.TYPES[type];
             if (typeof type.defaultValue === 'undefined')
-                throw Error("default value for type "+type.name+" is not supported");
+                throw Error("default value for type " + type.name + " is not supported");
             if (type == ProtoBuf.TYPES["bytes"])
                 return new ByteBuffer(0);
             return type.defaultValue;
@@ -1799,7 +1805,7 @@
             throw Error("not convertible to Long");
         }
 
-        ElementPrototype.toString = function() {
+        ElementPrototype.toString = function () {
             return (this.name || '') + (this.isMapKey ? 'map' : 'value') + ' element';
         }
 
@@ -1811,10 +1817,10 @@
          * @throws {Error} If the value cannot be verified for this element slot
          * @expose
          */
-        ElementPrototype.verifyValue = function(value) {
+        ElementPrototype.verifyValue = function (value) {
             var self = this;
             function fail(val, msg) {
-                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
+                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
             }
             switch (this.type) {
                 // Signed 32bit
@@ -1877,7 +1883,7 @@
                 case ProtoBuf.TYPES["string"]:
                     if (typeof value !== 'string' && !(value && value instanceof String))
                         fail(typeof value, "not a string");
-                    return ""+value; // Convert String object to string
+                    return "" + value; // Convert String object to string
 
                 // Length-delimited bytes
                 case ProtoBuf.TYPES["bytes"]:
@@ -1888,7 +1894,7 @@
                 // Constant enum value
                 case ProtoBuf.TYPES["enum"]: {
                     var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);
-                    for (i=0; i<values.length; i++)
+                    for (i = 0; i < values.length; i++)
                         if (values[i].name == value)
                             return values[i].id;
                         else if (values[i].id == value)
@@ -1927,7 +1933,7 @@
             }
 
             // We should never end here
-            throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
+            throw Error("[INTERNAL] Illegal value for " + this.toString(true) + ": " + value + " (undefined type " + this.type + ")");
         };
 
         /**
@@ -1938,7 +1944,7 @@
          * @throws {Error} If the value cannot be calculated
          * @expose
          */
-        ElementPrototype.calculateLength = function(id, value) {
+        ElementPrototype.calculateLength = function (id, value) {
             if (value === null) return 0; // Nothing to encode
             // Tag has already been written
             var n;
@@ -1972,7 +1978,7 @@
                     return ByteBuffer.calculateVarint32(n) + n;
                 case ProtoBuf.TYPES["bytes"]:
                     if (value.remaining() < 0)
-                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
+                        throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                     return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();
                 case ProtoBuf.TYPES["message"]:
                     n = this.resolvedType.calculate(value);
@@ -1982,7 +1988,7 @@
                     return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);
             }
             // We should never end here
-            throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
+            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
         };
 
         /**
@@ -1994,7 +2000,7 @@
          * @throws {Error} If the value cannot be encoded
          * @expose
          */
-        ElementPrototype.encodeValue = function(id, value, buffer) {
+        ElementPrototype.encodeValue = function (id, value, buffer) {
             if (value === null) return buffer; // Nothing to encode
             // Tag has already been written
 
@@ -2081,7 +2087,7 @@
                 // Length-delimited bytes
                 case ProtoBuf.TYPES["bytes"]:
                     if (value.remaining() < 0)
-                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
+                        throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
                     var prevOffset = value.offset;
                     buffer.writeVarint32(value.remaining());
                     buffer.append(value);
@@ -2104,7 +2110,7 @@
 
                 default:
                     // We should never end here
-                    throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
+                    throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
             }
             return buffer;
         };
@@ -2118,7 +2124,7 @@
          * @throws {Error} If the field cannot be decoded
          * @expose
          */
-        ElementPrototype.decode = function(buffer, wireType, id) {
+        ElementPrototype.decode = function (buffer, wireType, id) {
             if (wireType != this.type.wireType)
                 throw Error("Unexpected wire type for element");
 
@@ -2188,9 +2194,9 @@
                 case ProtoBuf.TYPES["bytes"]: {
                     nBytes = buffer.readVarint32();
                     if (buffer.remaining() < nBytes)
-                        throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
+                        throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());
                     value = buffer.clone(); // Offset already set
-                    value.limit = value.offset+nBytes;
+                    value.limit = value.offset + nBytes;
                     buffer.offset += nBytes;
                     return value;
                 }
@@ -2218,7 +2224,7 @@
          * @param {string} str The string value
          * @returns {*} The value
          */
-        ElementPrototype.valueFromString = function(str) {
+        ElementPrototype.valueFromString = function (str) {
             if (!this.isMapKey) {
                 throw Error("valueFromString() called on non-map-key element");
             }
@@ -2236,17 +2242,17 @@
                 case ProtoBuf.TYPES["sfixed64"]:
                 case ProtoBuf.TYPES["uint64"]:
                 case ProtoBuf.TYPES["fixed64"]:
-                      // Long-based fields support conversions from string already.
-                      return this.verifyValue(str);
+                    // Long-based fields support conversions from string already.
+                    return this.verifyValue(str);
 
                 case ProtoBuf.TYPES["bool"]:
-                      return str === "true";
+                    return str === "true";
 
                 case ProtoBuf.TYPES["string"]:
-                      return this.verifyValue(str);
+                    return this.verifyValue(str);
 
                 case ProtoBuf.TYPES["bytes"]:
-                      return ByteBuffer.fromBinary(str);
+                    return ByteBuffer.fromBinary(str);
             }
         };
 
@@ -2265,7 +2271,7 @@
          * @param {*} val The value
          * @returns {string} The string form of the value.
          */
-        ElementPrototype.valueToString = function(value) {
+        ElementPrototype.valueToString = function (value) {
             if (!this.isMapKey) {
                 throw Error("valueToString() called on non-map-key element");
             }
@@ -2295,7 +2301,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.Namespace
          */
-        var Message = function(builder, parent, name, options, isGroup, syntax) {
+        var Message = function (builder, parent, name, options, isGroup, syntax) {
             Namespace.call(this, builder, parent, name, options, syntax);
 
             /**
@@ -2362,12 +2368,12 @@
          * @throws {Error} If the message cannot be built
          * @expose
          */
-        MessagePrototype.build = function(rebuild) {
+        MessagePrototype.build = function (rebuild) {
             if (this.clazz && !rebuild)
                 return this.clazz;
 
             // Create the runtime Message class in its own scope
-            var clazz = (function(ProtoBuf, T) {
+            var clazz = (function (ProtoBuf, T) {
 
                 var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
                     oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);
@@ -2381,18 +2387,18 @@
                  * @constructor
                  * @throws {Error} If the message cannot be created
                  */
-                var Message = function(values, var_args) {
+                var Message = function (values, var_args) {
                     ProtoBuf.Builder.Message.call(this);
 
                     // Create virtual oneof properties
-                    for (var i=0, k=oneofs.length; i<k; ++i)
+                    for (var i = 0, k = oneofs.length; i < k; ++i)
                         this[oneofs[i].name] = null;
                     // Create fields and set default values
-                    for (i=0, k=fields.length; i<k; ++i) {
+                    for (i = 0, k = fields.length; i < k; ++i) {
                         var field = fields[i];
                         this[field.name] =
                             field.repeated ? [] :
-                            (field.map ? new ProtoBuf.Map(field) : null);
+                                (field.map ? new ProtoBuf.Map(field) : null);
                         if ((field.required || T.syntax === 'proto3') &&
                             field.defaultValue !== null)
                             this[field.name] = field.defaultValue;
@@ -2410,7 +2416,7 @@
                             /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
                             this.$set(values);
                         } else // Set field values from arguments, in declaration order
-                            for (i=0, k=arguments.length; i<k; ++i)
+                            for (i = 0, k = arguments.length; i < k; ++i)
                                 if (typeof (value = arguments[i]) !== 'undefined')
                                     this.$set(fields[i].name, value); // May throw
                     }
@@ -2433,15 +2439,15 @@
                  * @throws {Error} If the value cannot be added
                  * @expose
                  */
-                MessagePrototype.add = function(key, value, noAssert) {
+                MessagePrototype.add = function (key, value, noAssert) {
                     var field = T._fieldsByName[key];
                     if (!noAssert) {
                         if (!field)
-                            throw Error(this+"#"+key+" is undefined");
+                            throw Error(this + "#" + key + " is undefined");
                         if (!(field instanceof ProtoBuf.Reflect.Message.Field))
-                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
+                            throw Error(this + "#" + key + " is not a field: " + field.toString(true)); // May throw if it's an enum or embedded message
                         if (!field.repeated)
-                            throw Error(this+"#"+key+" is not a repeated field");
+                            throw Error(this + "#" + key + " is not a repeated field");
                         value = field.verifyValue(value, true);
                     }
                     if (this[key] === null)
@@ -2474,7 +2480,7 @@
                  * @throws {Error} If the value cannot be set
                  * @expose
                  */
-                MessagePrototype.set = function(keyOrObj, value, noAssert) {
+                MessagePrototype.set = function (keyOrObj, value, noAssert) {
                     if (keyOrObj && typeof keyOrObj === 'object') {
                         noAssert = value;
                         for (var ikey in keyOrObj) {
@@ -2487,9 +2493,9 @@
                     var field = T._fieldsByName[keyOrObj];
                     if (!noAssert) {
                         if (!field)
-                            throw Error(this+"#"+keyOrObj+" is not a field: undefined");
+                            throw Error(this + "#" + keyOrObj + " is not a field: undefined");
                         if (!(field instanceof ProtoBuf.Reflect.Message.Field))
-                            throw Error(this+"#"+keyOrObj+" is not a field: "+field.toString(true));
+                            throw Error(this + "#" + keyOrObj + " is not a field: " + field.toString(true));
                         this[field.name] = (value = field.verifyValue(value)); // May throw
                     } else
                         this[keyOrObj] = value;
@@ -2527,14 +2533,14 @@
                  * @throws {Error} If there is no such field
                  * @expose
                  */
-                MessagePrototype.get = function(key, noAssert) {
+                MessagePrototype.get = function (key, noAssert) {
                     if (noAssert)
                         return this[key];
                     var field = T._fieldsByName[key];
                     if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))
-                        throw Error(this+"#"+key+" is not a field: undefined");
+                        throw Error(this + "#" + key + " is not a field: undefined");
                     if (!(field instanceof ProtoBuf.Reflect.Message.Field))
-                        throw Error(this+"#"+key+" is not a field: "+field.toString(true));
+                        throw Error(this + "#" + key + " is not a field: " + field.toString(true));
                     return this[field.name];
                 };
 
@@ -2551,23 +2557,23 @@
 
                 // Getters and setters
 
-                for (var i=0; i<fields.length; i++) {
+                for (var i = 0; i < fields.length; i++) {
                     var field = fields[i];
                     // no setters for extension fields as these are named by their fqn
                     if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)
                         continue;
 
                     if (T.builder.options['populateAccessors'])
-                        (function(field) {
+                        (function (field) {
                             // set/get[SomeValue]
-                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {
-                                return match.toUpperCase().replace('_','');
+                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function (match) {
+                                return match.toUpperCase().replace('_', '');
                             });
-                            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);
+                            Name = Name.substring(0, 1).toUpperCase() + Name.substring(1);
 
                             // set/get_[some_value] FIXME: Do we really need these?
-                            var name = field.originalName.replace(/([A-Z])/g, function(match) {
-                                return "_"+match;
+                            var name = field.originalName.replace(/([A-Z])/g, function (match) {
+                                return "_" + match;
                             });
 
                             /**
@@ -2578,7 +2584,7 @@
                              * @returns {!ProtoBuf.Builder.Message}
                              * @inner
                              */
-                            var setter = function(value, noAssert) {
+                            var setter = function (value, noAssert) {
                                 this[field.name] = noAssert ? value : field.verifyValue(value);
                                 return this;
                             };
@@ -2589,11 +2595,11 @@
                              * @returns {*}
                              * @inner
                              */
-                            var getter = function() {
+                            var getter = function () {
                                 return this[field.name];
                             };
 
-                            if (T.getChild("set"+Name) === null)
+                            if (T.getChild("set" + Name) === null)
                                 /**
                                  * Sets a value. This method is present for each field, but only if there is no name conflict with
                                  *  another field.
@@ -2605,9 +2611,9 @@
                                  * @abstract
                                  * @throws {Error} If the value cannot be set
                                  */
-                                MessagePrototype["set"+Name] = setter;
+                                MessagePrototype["set" + Name] = setter;
 
-                            if (T.getChild("set_"+name) === null)
+                            if (T.getChild("set_" + name) === null)
                                 /**
                                  * Sets a value. This method is present for each field, but only if there is no name conflict with
                                  *  another field.
@@ -2619,9 +2625,9 @@
                                  * @abstract
                                  * @throws {Error} If the value cannot be set
                                  */
-                                MessagePrototype["set_"+name] = setter;
+                                MessagePrototype["set_" + name] = setter;
 
-                            if (T.getChild("get"+Name) === null)
+                            if (T.getChild("get" + Name) === null)
                                 /**
                                  * Gets a value. This method is present for each field, but only if there is no name conflict with
                                  *  another field.
@@ -2630,9 +2636,9 @@
                                  * @abstract
                                  * @return {*} The value
                                  */
-                                MessagePrototype["get"+Name] = getter;
+                                MessagePrototype["get" + Name] = getter;
 
-                            if (T.getChild("get_"+name) === null)
+                            if (T.getChild("get_" + name) === null)
                                 /**
                                  * Gets a value. This method is present for each field, but only if there is no name conflict with
                                  *  another field.
@@ -2641,7 +2647,7 @@
                                  * @return {*} The value
                                  * @abstract
                                  */
-                                MessagePrototype["get_"+name] = getter;
+                                MessagePrototype["get_" + name] = getter;
 
                         })(field);
                 }
@@ -2662,21 +2668,21 @@
                  * @see ProtoBuf.Builder.Message#encodeHex
                  * @see ProtoBuf.Builder.Message#encodeAB
                  */
-                MessagePrototype.encode = function(buffer, noVerify) {
+                MessagePrototype.encode = function (buffer, noVerify) {
                     if (typeof buffer === 'boolean')
                         noVerify = buffer,
-                        buffer = undefined;
+                            buffer = undefined;
                     var isNew = false;
                     if (!buffer)
                         buffer = new ByteBuffer(),
-                        isNew = true;
+                            isNew = true;
                     var le = buffer.littleEndian;
                     try {
                         T.encode(this, buffer.LE(), noVerify);
                         return (isNew ? buffer.flip() : buffer).LE(le);
                     } catch (e) {
                         buffer.LE(le);
-                        throw(e);
+                        throw (e);
                     }
                 };
 
@@ -2688,7 +2694,7 @@
                  * @return {!ByteBuffer} Encoded message as a ByteBuffer
                  * @expose
                  */
-                Message.encode = function(data, buffer, noVerify) {
+                Message.encode = function (data, buffer, noVerify) {
                     return new Message(data).encode(buffer, noVerify);
                 };
 
@@ -2700,7 +2706,7 @@
                  * @throws {Error} If the message cannot be calculated or if required fields are missing.
                  * @expose
                  */
-                MessagePrototype.calculate = function() {
+                MessagePrototype.calculate = function () {
                     return T.calculate(this);
                 };
 
@@ -2715,11 +2721,11 @@
                  *  returns the encoded ByteBuffer in the `encoded` property on the error.
                  * @expose
                  */
-                MessagePrototype.encodeDelimited = function(buffer, noVerify) {
+                MessagePrototype.encodeDelimited = function (buffer, noVerify) {
                     var isNew = false;
                     if (!buffer)
                         buffer = new ByteBuffer(),
-                        isNew = true;
+                            isNew = true;
                     var enc = new ByteBuffer().LE();
                     T.encode(this, enc, noVerify).flip();
                     buffer.writeVarint32(enc.remaining());
@@ -2736,12 +2742,12 @@
                  *  returns the encoded ArrayBuffer in the `encoded` property on the error.
                  * @expose
                  */
-                MessagePrototype.encodeAB = function() {
+                MessagePrototype.encodeAB = function () {
                     try {
                         return this.encode().toArrayBuffer();
                     } catch (e) {
                         if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
-                        throw(e);
+                        throw (e);
                     }
                 };
 
@@ -2765,12 +2771,12 @@
                  *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
                  * @expose
                  */
-                MessagePrototype.encodeNB = function() {
+                MessagePrototype.encodeNB = function () {
                     try {
                         return this.encode().toBuffer();
                     } catch (e) {
                         if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
-                        throw(e);
+                        throw (e);
                     }
                 };
 
@@ -2794,12 +2800,12 @@
                  *  still returns the encoded base64 string in the `encoded` property on the error.
                  * @expose
                  */
-                MessagePrototype.encode64 = function() {
+                MessagePrototype.encode64 = function () {
                     try {
                         return this.encode().toBase64();
                     } catch (e) {
                         if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
-                        throw(e);
+                        throw (e);
                     }
                 };
 
@@ -2823,12 +2829,12 @@
                  *  still returns the encoded hex string in the `encoded` property on the error.
                  * @expose
                  */
-                MessagePrototype.encodeHex = function() {
+                MessagePrototype.encodeHex = function () {
                     try {
                         return this.encode().toHex();
                     } catch (e) {
                         if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
-                        throw(e);
+                        throw (e);
                     }
                 };
 
@@ -2873,7 +2879,7 @@
                     // Clone arrays
                     if (Array.isArray(obj)) {
                         clone = [];
-                        obj.forEach(function(v, k) {
+                        obj.forEach(function (v, k) {
                             clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
                         });
                         return clone;
@@ -2906,7 +2912,7 @@
                  * @returns {Object.<string,*>} Raw payload
                  * @expose
                  */
-                MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) {
+                MessagePrototype.toRaw = function (binaryAsBase64, longsAsStrings) {
                     return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
                 };
 
@@ -2915,12 +2921,12 @@
                  * @returns {string} JSON string
                  * @expose
                  */
-                MessagePrototype.encodeJSON = function() {
+                MessagePrototype.encodeJSON = function () {
                     return JSON.stringify(
                         cloneRaw(this,
                              /* binary-as-base64 */ true,
                              /* longs-as-strings */ true,
-                             this.$type
+                            this.$type
                         )
                     );
                 };
@@ -2939,10 +2945,10 @@
                  * @see ProtoBuf.Builder.Message.decode64
                  * @see ProtoBuf.Builder.Message.decodeHex
                  */
-                Message.decode = function(buffer, length, enc) {
+                Message.decode = function (buffer, length, enc) {
                     if (typeof length === 'string')
                         enc = length,
-                        length = -1;
+                            length = -1;
                     if (typeof buffer === 'string')
                         buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                     else if (!ByteBuffer.isByteBuffer(buffer))
@@ -2954,7 +2960,7 @@
                         return msg;
                     } catch (e) {
                         buffer.LE(le);
-                        throw(e);
+                        throw (e);
                     }
                 };
 
@@ -2969,7 +2975,7 @@
                  *  returns the decoded message with missing fields in the `decoded` property on the error.
                  * @expose
                  */
-                Message.decodeDelimited = function(buffer, enc) {
+                Message.decodeDelimited = function (buffer, enc) {
                     if (typeof buffer === 'string')
                         buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
                     else if (!ByteBuffer.isByteBuffer(buffer))
@@ -3002,7 +3008,7 @@
                  *  returns the decoded message with missing fields in the `decoded` property on the error.
                  * @expose
                  */
-                Message.decode64 = function(str) {
+                Message.decode64 = function (str) {
                     return Message.decode(str, "base64");
                 };
 
@@ -3016,7 +3022,7 @@
                  *  returns the decoded message with missing fields in the `decoded` property on the error.
                  * @expose
                  */
-                Message.decodeHex = function(str) {
+                Message.decodeHex = function (str) {
                     return Message.decode(str, "hex");
                 };
 
@@ -3030,7 +3036,7 @@
                  * missing.
                  * @expose
                  */
-                Message.decodeJSON = function(str) {
+                Message.decodeJSON = function (str) {
                     return new Message(JSON.parse(str));
                 };
 
@@ -3043,7 +3049,7 @@
                  * @return {string} String representation as of ".Fully.Qualified.MessageName"
                  * @expose
                  */
-                MessagePrototype.toString = function() {
+                MessagePrototype.toString = function () {
                     return T.toString();
                 };
 
@@ -3083,9 +3089,9 @@
 
                 if (Object.defineProperty)
                     Object.defineProperty(Message, '$options', { "value": T.buildOpt() }),
-                    Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }),
-                    Object.defineProperty(Message, "$type", { "value": T }),
-                    Object.defineProperty(MessagePrototype, "$type", { "value": T });
+                        Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }),
+                        Object.defineProperty(Message, "$type", { "value": T }),
+                        Object.defineProperty(MessagePrototype, "$type", { "value": T });
 
                 return Message;
 
@@ -3096,22 +3102,22 @@
             this._fieldsById = {};
             this._fieldsByName = {};
             this._oneofsByName = {};
-            for (var i=0, k=this.children.length, child; i<k; i++) {
+            for (var i = 0, k = this.children.length, child; i < k; i++) {
                 child = this.children[i];
                 if (child instanceof Enum || child instanceof Message || child instanceof Service) {
                     if (clazz.hasOwnProperty(child.name))
-                        throw Error("Illegal reflect child of "+this.toString(true)+": "+child.toString(true)+" cannot override static property '"+child.name+"'");
+                        throw Error("Illegal reflect child of " + this.toString(true) + ": " + child.toString(true) + " cannot override static property '" + child.name + "'");
                     clazz[child.name] = child.build();
                 } else if (child instanceof Message.Field)
                     child.build(),
-                    this._fields.push(child),
-                    this._fieldsById[child.id] = child,
-                    this._fieldsByName[child.name] = child;
+                        this._fields.push(child),
+                        this._fieldsById[child.id] = child,
+                        this._fieldsByName[child.name] = child;
                 else if (child instanceof Message.OneOf) {
                     this._oneofsByName[child.name] = child;
                 }
                 else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
-                    throw Error("Illegal reflect child of "+this.toString(true)+": "+this.children[i].toString(true));
+                    throw Error("Illegal reflect child of " + this.toString(true) + ": " + this.children[i].toString(true));
             }
 
             return this.clazz = clazz;
@@ -3126,10 +3132,10 @@
          * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
          * @expose
          */
-        MessagePrototype.encode = function(message, buffer, noVerify) {
+        MessagePrototype.encode = function (message, buffer, noVerify) {
             var fieldMissing = null,
                 field;
-            for (var i=0, k=this._fields.length, val; i<k; ++i) {
+            for (var i = 0, k = this._fields.length, val; i < k; ++i) {
                 field = this._fields[i];
                 val = message[field.name];
                 if (field.required && val === null) {
@@ -3139,9 +3145,9 @@
                     field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
             }
             if (fieldMissing !== null) {
-                var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);
+                var err = Error("Missing at least one required field for " + this.toString(true) + ": " + fieldMissing);
                 err["encoded"] = buffer; // Still expose what we got
-                throw(err);
+                throw (err);
             }
             return buffer;
         };
@@ -3153,12 +3159,12 @@
          * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
          * @expose
          */
-        MessagePrototype.calculate = function(message) {
-            for (var n=0, i=0, k=this._fields.length, field, val; i<k; ++i) {
+        MessagePrototype.calculate = function (message) {
+            for (var n = 0, i = 0, k = this._fields.length, field, val; i < k; ++i) {
                 field = this._fields[i];
                 val = message[field.name];
                 if (field.required && val === null)
-                   throw Error("Missing at least one required field for "+this.toString(true)+": "+field);
+                    throw Error("Missing at least one required field for " + this.toString(true) + ": " + field);
                 else
                     n += field.calculate(val, message);
             }
@@ -3196,12 +3202,12 @@
                     if (id === expectedId)
                         return false;
                     else
-                        throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");
+                        throw Error("Illegal GROUPEND after unknown group: " + id + " (" + expectedId + " expected)");
                 case ProtoBuf.WIRE_TYPES.BITS32:
                     buf.offset += 4;
                     break;
                 default:
-                    throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);
+                    throw Error("Illegal wire type in unknown group " + expectedId + ": " + wireType);
             }
             return true;
         }
@@ -3215,19 +3221,19 @@
          * @throws {Error} If the message cannot be decoded
          * @expose
          */
-        MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {
+        MessagePrototype.decode = function (buffer, length, expectedGroupEndId) {
             if (typeof length !== 'number')
                 length = -1;
             var start = buffer.offset,
                 msg = new (this.clazz)(),
                 tag, wireType, id, field;
-            while (buffer.offset < start+length || (length === -1 && buffer.remaining() > 0)) {
+            while (buffer.offset < start + length || (length === -1 && buffer.remaining() > 0)) {
                 tag = buffer.readVarint32();
                 wireType = tag & 0x07;
                 id = tag >>> 3;
                 if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                     if (id !== expectedGroupEndId)
-                        throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
+                        throw Error("Illegal group end indicator for " + this.toString(true) + ": " + id + " (" + (expectedGroupEndId ? expectedGroupEndId + " expected" : "not a group") + ")");
                     break;
                 }
                 if (!(field = this._fieldsById[id])) {
@@ -3247,10 +3253,10 @@
                             buffer.offset += len;
                             break;
                         case ProtoBuf.WIRE_TYPES.STARTGROUP:
-                            while (skipTillGroupEnd(id, buffer)) {}
+                            while (skipTillGroupEnd(id, buffer)) { }
                             break;
                         default:
-                            throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
+                            throw Error("Illegal wire type for unknown field " + id + " in " + this.toString(true) + "#decode: " + wireType);
                     }
                     continue;
                 }
@@ -3271,7 +3277,7 @@
             }
 
             // Check if all required fields are present and set default values for optional fields that are not
-            for (var i=0, k=this._fields.length; i<k; ++i) {
+            for (var i = 0, k = this._fields.length; i < k; ++i) {
                 field = this._fields[i];
                 if (msg[field.name] === null) {
                     if (this.syntax === "proto3") { // Proto3 sets default values by specification
@@ -3279,7 +3285,7 @@
                     } else if (field.required) {
                         var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                         err["decoded"] = msg; // Still expose what we got
-                        throw(err);
+                        throw (err);
                     } else if (ProtoBuf.populateDefaults && field.defaultValue !== null)
                         msg[field.name] = field.defaultValue;
                 }
@@ -3309,7 +3315,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.T
          */
-        var Field = function(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
+        var Field = function (builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
             T.call(this, builder, message, name);
 
             /**
@@ -3435,7 +3441,7 @@
          * @override
          * @expose
          */
-        FieldPrototype.build = function() {
+        FieldPrototype.build = function () {
             this.element = new Element(this.type, this.resolvedType, false, this.syntax, this.name);
             if (this.map)
                 this.keyElement = new Element(this.keyType, undefined, true, this.syntax, this.name);
@@ -3458,11 +3464,11 @@
          * @throws {Error} If the value cannot be set for this field
          * @expose
          */
-        FieldPrototype.verifyValue = function(value, skipRepeated) {
+        FieldPrototype.verifyValue = function (value, skipRepeated) {
             skipRepeated = skipRepeated || false;
             var self = this;
             function fail(val, msg) {
-                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
+                throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
             }
             if (value === null) { // NULL values for optional fields
                 if (this.required)
@@ -3476,7 +3482,7 @@
                 if (!Array.isArray(value))
                     value = [value];
                 var res = [];
-                for (i=0; i<value.length; i++)
+                for (i = 0; i < value.length; i++)
                     res.push(this.element.verifyValue(value[i]));
                 return res;
             }
@@ -3485,7 +3491,7 @@
                     // If not already a Map, attempt to convert.
                     if (!(value instanceof Object)) {
                         fail(typeof value,
-                             "expected ProtoBuf.Map or raw object for map field");
+                            "expected ProtoBuf.Map or raw object for map field");
                     }
                     return new ProtoBuf.Map(this, value);
                 } else {
@@ -3506,7 +3512,7 @@
          * @param {!ProtoBuf.Builder.Message} message Runtime message
          * @return {boolean} Whether the field will be present on the wire
          */
-        FieldPrototype.hasWirePresence = function(value, message) {
+        FieldPrototype.hasWirePresence = function (value, message) {
             if (this.syntax !== 'proto3')
                 return (value !== null);
             if (this.oneof && message[this.oneof.name] === this.name)
@@ -3558,9 +3564,9 @@
          * @throws {Error} If the field cannot be encoded
          * @expose
          */
-        FieldPrototype.encode = function(value, buffer, message) {
+        FieldPrototype.encode = function (value, buffer, message) {
             if (this.type === null || typeof this.type !== 'object')
-                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
+                throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
             if (value === null || (this.repeated && value.length == 0))
                 return buffer; // Optional omitted
             try {
@@ -3575,27 +3581,27 @@
                         buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                         buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                         var start = buffer.offset; // Remember where the contents begin
-                        for (i=0; i<value.length; i++)
+                        for (i = 0; i < value.length; i++)
                             this.element.encodeValue(this.id, value[i], buffer);
-                        var len = buffer.offset-start,
+                        var len = buffer.offset - start,
                             varintLen = ByteBuffer.calculateVarint32(len);
                         if (varintLen > 1) { // We need to move the contents
                             var contents = buffer.slice(start, buffer.offset);
-                            start += varintLen-1;
+                            start += varintLen - 1;
                             buffer.offset = start;
                             buffer.append(contents);
                         }
-                        buffer.writeVarint32(len, start-varintLen);
+                        buffer.writeVarint32(len, start - varintLen);
                     } else {
                         // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                         // message has zero or more key-value pairs with the same tag number"
-                        for (i=0; i<value.length; i++)
+                        for (i = 0; i < value.length; i++)
                             buffer.writeVarint32((this.id << 3) | this.type.wireType),
-                            this.element.encodeValue(this.id, value[i], buffer);
+                                this.element.encodeValue(this.id, value[i], buffer);
                     }
                 } else if (this.map) {
                     // Write out each map entry as a submessage.
-                    value.forEach(function(val, key, m) {
+                    value.forEach(function (val, key, m) {
                         // Compute the length of the submessage (key, val) pair.
                         var length =
                             ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
@@ -3620,7 +3626,7 @@
                     }
                 }
             } catch (e) {
-                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
+                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
             }
             return buffer;
         };
@@ -3632,10 +3638,10 @@
          * @returns {number} Byte length
          * @expose
          */
-        FieldPrototype.calculate = function(value, message) {
+        FieldPrototype.calculate = function (value, message) {
             value = this.verifyValue(value); // May throw
             if (this.type === null || typeof this.type !== 'object')
-                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);
+                throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
             if (value === null || (this.repeated && value.length == 0))
                 return 0; // Optional omitted
             var n = 0;
@@ -3645,18 +3651,18 @@
                     if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                         n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);
                         ni = 0;
-                        for (i=0; i<value.length; i++)
+                        for (i = 0; i < value.length; i++)
                             ni += this.element.calculateLength(this.id, value[i]);
                         n += ByteBuffer.calculateVarint32(ni);
                         n += ni;
                     } else {
-                        for (i=0; i<value.length; i++)
+                        for (i = 0; i < value.length; i++)
                             n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),
-                            n += this.element.calculateLength(this.id, value[i]);
+                                n += this.element.calculateLength(this.id, value[i]);
                     }
                 } else if (this.map) {
                     // Each map entry becomes a submessage.
-                    value.forEach(function(val, key, m) {
+                    value.forEach(function (val, key, m) {
                         // Compute the length of the submessage (key, val) pair.
                         var length =
                             ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +
@@ -3675,7 +3681,7 @@
                     }
                 }
             } catch (e) {
-                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");
+                throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
             }
             return n;
         };
@@ -3690,7 +3696,7 @@
          * @throws {Error} If the field cannot be decoded
          * @expose
          */
-        FieldPrototype.decode = function(wireType, buffer, skipRepeated) {
+        FieldPrototype.decode = function (wireType, buffer, skipRepeated) {
             var value, nBytes;
 
             // We expect wireType to match the underlying type's wireType unless we see
@@ -3698,10 +3704,10 @@
             var wireTypeOK =
                 (!this.map && wireType == this.type.wireType) ||
                 (!skipRepeated && this.repeated && this.options["packed"] &&
-                 wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||
+                    wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||
                 (this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM);
             if (!wireTypeOK)
-                throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");
+                throw Error("Illegal wire type for field " + this.toString(true) + ": " + wireType + " (" + this.type.wireType + " expected)");
 
             // Handle packed repeated fields.
             if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
@@ -3725,7 +3731,7 @@
                 // Read the length
                 nBytes = buffer.readVarint32();
                 if (buffer.remaining() < nBytes)
-                    throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
+                    throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());
 
                 // Get a sub-buffer of this key/value submessage
                 var msgbuf = buffer.clone();
@@ -3771,7 +3777,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.Message.Field
          */
-        var ExtensionField = function(builder, message, rule, type, name, id, options) {
+        var ExtensionField = function (builder, message, rule, type, name, id, options) {
             Field.call(this, builder, message, rule, /* keytype = */ null, type, name, id, options);
 
             /**
@@ -3800,7 +3806,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.T
          */
-        var OneOf = function(builder, message, name) {
+        var OneOf = function (builder, message, name) {
             T.call(this, builder, message, name);
 
             /**
@@ -3828,7 +3834,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.Namespace
          */
-        var Enum = function(builder, parent, name, options, syntax) {
+        var Enum = function (builder, parent, name, options, syntax) {
             Namespace.call(this, builder, parent, name, options, syntax);
 
             /**
@@ -3851,9 +3857,9 @@
          * @returns {?string} Name or `null` if not present
          * @expose
          */
-        Enum.getName = function(enm, value) {
+        Enum.getName = function (enm, value) {
             var keys = Object.keys(enm);
-            for (var i=0, key; i<keys.length; ++i)
+            for (var i = 0, key; i < keys.length; ++i)
                 if (enm[key = keys[i]] === value)
                     return key;
             return null;
@@ -3871,12 +3877,12 @@
          * @returns {!Object.<string,number>}
          * @expose
          */
-        EnumPrototype.build = function(rebuild) {
+        EnumPrototype.build = function (rebuild) {
             if (this.object && !rebuild)
                 return this.object;
             var enm = new ProtoBuf.Builder.Enum(),
                 values = this.getChildren(Enum.Value);
-            for (var i=0, k=values.length; i<k; ++i)
+            for (var i = 0, k = values.length; i < k; ++i)
                 enm[values[i]['name']] = values[i]['id'];
             if (Object.defineProperty)
                 Object.defineProperty(enm, '$options', {
@@ -3902,7 +3908,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.T
          */
-        var Value = function(builder, enm, name, id) {
+        var Value = function (builder, enm, name, id) {
             T.call(this, builder, enm, name);
 
             /**
@@ -3936,7 +3942,7 @@
          * @param {string} name Object name
          * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
          */
-        var Extension = function(builder, parent, name, field) {
+        var Extension = function (builder, parent, name, field) {
             T.call(this, builder, parent, name);
 
             /**
@@ -3966,7 +3972,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.Namespace
          */
-        var Service = function(builder, root, name, options) {
+        var Service = function (builder, root, name, options) {
             Namespace.call(this, builder, root, name, options);
 
             /**
@@ -3995,12 +4001,12 @@
          * @throws {Error} If the message cannot be built
          * @expose
          */
-        ServicePrototype.build = function(rebuild) {
+        ServicePrototype.build = function (rebuild) {
             if (this.clazz && !rebuild)
                 return this.clazz;
 
             // Create the runtime Service class in its own scope
-            return this.clazz = (function(ProtoBuf, T) {
+            return this.clazz = (function (ProtoBuf, T) {
 
                 /**
                  * Constructs a new runtime Service.
@@ -4010,7 +4016,7 @@
                  * @constructor
                  * @throws {Error} If the service cannot be created
                  */
-                var Service = function(rpcImpl) {
+                var Service = function (rpcImpl) {
                     ProtoBuf.Builder.Service.call(this);
 
                     /**
@@ -4019,7 +4025,7 @@
                      * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                      * @expose
                      */
-                    this.rpcImpl = rpcImpl || function(name, msg, callback) {
+                    this.rpcImpl = rpcImpl || function (name, msg, callback) {
                         // This is what a user has to implement: A function receiving the method name, the actual message to
                         // send (type checked) and the callback that's either provided with the error as its first
                         // argument or null and the actual response message.
@@ -4055,11 +4061,11 @@
                  */
 
                 var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);
-                for (var i=0; i<rpc.length; i++) {
-                    (function(method) {
+                for (var i = 0; i < rpc.length; i++) {
+                    (function (method) {
 
                         // service#Method(message, callback)
-                        ServicePrototype[method.name] = function(req, callback) {
+                        ServicePrototype[method.name] = function (req, callback) {
                             try {
                                 try {
                                     // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
@@ -4072,7 +4078,7 @@
                                     throw Error("Illegal arguments");
                                 if (!(req instanceof method.resolvedRequestType.clazz))
                                     req = new method.resolvedRequestType.clazz(req);
-                                this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
+                                this.rpcImpl(method.fqn(), req, function (err, res) { // Assumes that this is properly async
                                     if (err) {
                                         callback(err);
                                         return;
@@ -4080,9 +4086,9 @@
                                     // Coalesce to empty string when service response has empty content
                                     if (res === null)
                                         res = ''
-                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
+                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) { }
                                     if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
-                                        callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
+                                        callback(Error("Illegal response type received in service method " + T.name + "#" + method.name));
                                         return;
                                     }
                                     callback(null, res);
@@ -4093,13 +4099,13 @@
                         };
 
                         // Service.Method(rpcImpl, message, callback)
-                        Service[method.name] = function(rpcImpl, req, callback) {
+                        Service[method.name] = function (rpcImpl, req, callback) {
                             new Service(rpcImpl)[method.name](req, callback);
                         };
 
                         if (Object.defineProperty)
                             Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),
-                            Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
+                                Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                     })(rpc[i]);
                 }
 
@@ -4139,9 +4145,9 @@
 
                 if (Object.defineProperty)
                     Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),
-                    Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }),
-                    Object.defineProperty(Service, "$type", { "value": T }),
-                    Object.defineProperty(ServicePrototype, "$type", { "value": T });
+                        Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }),
+                        Object.defineProperty(Service, "$type", { "value": T }),
+                        Object.defineProperty(ServicePrototype, "$type", { "value": T });
 
                 return Service;
 
@@ -4164,7 +4170,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.T
          */
-        var Method = function(builder, svc, name, options) {
+        var Method = function (builder, svc, name, options) {
             T.call(this, builder, svc, name);
 
             /**
@@ -4214,7 +4220,7 @@
          * @constructor
          * @extends ProtoBuf.Reflect.Service.Method
          */
-        var RPCMethod = function(builder, svc, name, request, response, request_stream, response_stream, options) {
+        var RPCMethod = function (builder, svc, name, request, response, request_stream, response_stream, options) {
             Method.call(this, builder, svc, name, options);
 
             /**
@@ -4282,7 +4288,7 @@
      * @alias ProtoBuf.Builder
      * @expose
      */
-    ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
+    ProtoBuf.Builder = (function (ProtoBuf, Lang, Reflect) {
         "use strict";
 
         /**
@@ -4292,7 +4298,7 @@
          * @param {Object.<string,*>=} options Options
          * @constructor
          */
-        var Builder = function(options) {
+        var Builder = function (options) {
 
             /**
              * Namespace.
@@ -4358,7 +4364,7 @@
          * @returns {boolean}
          * @expose
          */
-        Builder.isMessage = function(def) {
+        Builder.isMessage = function (def) {
             // Messages require a string name
             if (typeof def["name"] !== 'string')
                 return false;
@@ -4374,7 +4380,7 @@
          * @returns {boolean}
          * @expose
          */
-        Builder.isMessageField = function(def) {
+        Builder.isMessageField = function (def) {
             // Message fields require a string rule, name and type and an id
             if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                 return false;
@@ -4387,7 +4393,7 @@
          * @returns {boolean}
          * @expose
          */
-        Builder.isEnum = function(def) {
+        Builder.isEnum = function (def) {
             // Enums require a string name
             if (typeof def["name"] !== 'string')
                 return false;
@@ -4403,7 +4409,7 @@
          * @returns {boolean}
          * @expose
          */
-        Builder.isService = function(def) {
+        Builder.isService = function (def) {
             // Services require a string name and an rpc object
             if (typeof def["name"] !== 'string' || typeof def["rpc"] !== 'object' || !def["rpc"])
                 return false;
@@ -4416,7 +4422,7 @@
          * @returns {boolean}
          * @expose
          */
-        Builder.isExtend = function(def) {
+        Builder.isExtend = function (def) {
             // Extends rquire a string ref
             if (typeof def["ref"] !== 'string')
                 return false;
@@ -4430,7 +4436,7 @@
          * @returns {!ProtoBuf.Builder} this
          * @expose
          */
-        BuilderPrototype.reset = function() {
+        BuilderPrototype.reset = function () {
             this.ptr = this.ns;
             return this;
         };
@@ -4441,10 +4447,10 @@
          * @return {!ProtoBuf.Builder} this
          * @expose
          */
-        BuilderPrototype.define = function(namespace) {
+        BuilderPrototype.define = function (namespace) {
             if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace))
-                throw Error("illegal namespace: "+namespace);
-            namespace.split(".").forEach(function(part) {
+                throw Error("illegal namespace: " + namespace);
+            namespace.split(".").forEach(function (part) {
                 var ns = this.ptr.getChild(part);
                 if (ns === null) // Keep existing
                     this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
@@ -4460,7 +4466,7 @@
          * @throws {Error} If a message definition is invalid
          * @expose
          */
-        BuilderPrototype.create = function(defs) {
+        BuilderPrototype.create = function (defs) {
             if (!defs)
                 return this; // Nothing to create
             if (!Array.isArray(defs))
@@ -4477,7 +4483,7 @@
                 defs = stack.pop();
 
                 if (!Array.isArray(defs)) // Stack always contains entire namespaces
-                    throw Error("not a valid namespace: "+JSON.stringify(defs));
+                    throw Error("not a valid namespace: " + JSON.stringify(defs));
 
                 while (defs.length > 0) {
                     var def = defs.shift(); // Namespaces always contain an array of messages, enums and services
@@ -4488,20 +4494,20 @@
                         // Create OneOfs
                         var oneofs = {};
                         if (def["oneofs"])
-                            Object.keys(def["oneofs"]).forEach(function(name) {
+                            Object.keys(def["oneofs"]).forEach(function (name) {
                                 obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
                             }, this);
 
                         // Create fields
                         if (def["fields"])
-                            def["fields"].forEach(function(fld) {
-                                if (obj.getChild(fld["id"]|0) !== null)
-                                    throw Error("duplicate or invalid field id in "+obj.name+": "+fld['id']);
+                            def["fields"].forEach(function (fld) {
+                                if (obj.getChild(fld["id"] | 0) !== null)
+                                    throw Error("duplicate or invalid field id in " + obj.name + ": " + fld['id']);
                                 if (fld["options"] && typeof fld["options"] !== 'object')
-                                    throw Error("illegal field options in "+obj.name+"#"+fld["name"]);
+                                    throw Error("illegal field options in " + obj.name + "#" + fld["name"]);
                                 var oneof = null;
                                 if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]]))
-                                    throw Error("illegal oneof in "+obj.name+"#"+fld["name"]+": "+fld["oneof"]);
+                                    throw Error("illegal oneof in " + obj.name + "#" + fld["name"] + ": " + fld["oneof"]);
                                 fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                                 if (oneof)
                                     oneof.fields.push(fld);
@@ -4511,22 +4517,22 @@
                         // Push children to stack
                         var subObj = [];
                         if (def["enums"])
-                            def["enums"].forEach(function(enm) {
+                            def["enums"].forEach(function (enm) {
                                 subObj.push(enm);
                             });
                         if (def["messages"])
-                            def["messages"].forEach(function(msg) {
+                            def["messages"].forEach(function (msg) {
                                 subObj.push(msg);
                             });
                         if (def["services"])
-                            def["services"].forEach(function(svc) {
+                            def["services"].forEach(function (svc) {
                                 subObj.push(svc);
                             });
 
                         // Set extension ranges
                         if (def["extensions"]) {
                             if (typeof def["extensions"][0] === 'number') // pre 5.0.1
-                                obj.extensions = [ def["extensions"] ];
+                                obj.extensions = [def["extensions"]];
                             else
                                 obj.extensions = def["extensions"];
                         }
@@ -4546,7 +4552,7 @@
                     } else if (Builder.isEnum(def)) {
 
                         obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
-                        def["values"].forEach(function(val) {
+                        def["values"].forEach(function (val) {
                             obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
                         }, this);
                         this.ptr.addChild(obj);
@@ -4554,7 +4560,7 @@
                     } else if (Builder.isService(def)) {
 
                         obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
-                        Object.keys(def["rpc"]).forEach(function(name) {
+                        Object.keys(def["rpc"]).forEach(function (name) {
                             var mtd = def["rpc"][name];
                             obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                         }, this);
@@ -4564,25 +4570,25 @@
 
                         obj = this.ptr.resolve(def["ref"], true);
                         if (obj) {
-                            def["fields"].forEach(function(fld) {
-                                if (obj.getChild(fld['id']|0) !== null)
-                                    throw Error("duplicate extended field id in "+obj.name+": "+fld['id']);
+                            def["fields"].forEach(function (fld) {
+                                if (obj.getChild(fld['id'] | 0) !== null)
+                                    throw Error("duplicate extended field id in " + obj.name + ": " + fld['id']);
                                 // Check if field id is allowed to be extended
                                 if (obj.extensions) {
                                     var valid = false;
-                                    obj.extensions.forEach(function(range) {
+                                    obj.extensions.forEach(function (range) {
                                         if (fld["id"] >= range[0] && fld["id"] <= range[1])
                                             valid = true;
                                     });
                                     if (!valid)
-                                        throw Error("illegal extended field id in "+obj.name+": "+fld['id']+" (not within valid ranges)");
+                                        throw Error("illegal extended field id in " + obj.name + ": " + fld['id'] + " (not within valid ranges)");
                                 }
                                 // Convert extension field names to camel case notation if the override is set
                                 var name = fld["name"];
                                 if (this.options['convertFieldsToCamelCase'])
                                     name = ProtoBuf.Util.toCamelCase(name);
                                 // see #161: Extensions use their fully qualified name as their runtime key and...
-                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn()+'.'+name, fld["id"], fld["options"]);
+                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn() + '.' + name, fld["id"], fld["options"]);
                                 // ...are added on top of the current namespace as an extension which is used for
                                 // resolving their type later on (the extension always keeps the original name to
                                 // prevent naming collisions)
@@ -4593,10 +4599,10 @@
                             }, this);
 
                         } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
-                            throw Error("extended message "+def["ref"]+" is not defined");
+                            throw Error("extended message " + def["ref"] + " is not defined");
 
                     } else
-                        throw Error("not a valid definition: "+JSON.stringify(def));
+                        throw Error("not a valid definition: " + JSON.stringify(def));
 
                     def = null;
                     obj = null;
@@ -4617,13 +4623,13 @@
          */
         function propagateSyntax(parent) {
             if (parent['messages']) {
-                parent['messages'].forEach(function(child) {
+                parent['messages'].forEach(function (child) {
                     child["syntax"] = parent["syntax"];
                     propagateSyntax(child);
                 });
             }
             if (parent['enums']) {
-                parent['enums'].forEach(function(child) {
+                parent['enums'].forEach(function (child) {
                     child["syntax"] = parent["syntax"];
                 });
             }
@@ -4637,7 +4643,7 @@
          * @throws {Error} If the definition or file cannot be imported
          * @expose
          */
-        BuilderPrototype["import"] = function(json, filename) {
+        BuilderPrototype["import"] = function (json, filename) {
             var delim = '/';
 
             // Make sure to skip duplicate imports
@@ -4700,7 +4706,7 @@
                 } else
                     importRoot = null;
 
-                for (var i=0; i<json['imports'].length; i++) {
+                for (var i = 0; i < json['imports'].length; i++) {
                     if (typeof json['imports'][i] === 'string') { // Import file
                         if (!importRoot)
                             throw Error("cannot determine import root");
@@ -4717,18 +4723,18 @@
                             importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                         var contents = ProtoBuf.Util.fetch(importFilename);
                         if (contents === null)
-                            throw Error("failed to import '"+importFilename+"' in '"+filename+"': file not found");
+                            throw Error("failed to import '" + importFilename + "' in '" + filename + "': file not found");
                         if (/\.json$/i.test(importFilename)) // Always possible
-                            this["import"](JSON.parse(contents+""), importFilename); // May throw
+                            this["import"](JSON.parse(contents + ""), importFilename); // May throw
                         else
                             this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
                     } else // Import structure
                         if (!filename)
                             this["import"](json['imports'][i]);
                         else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
-                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
+                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function ($0, $1, $2) { return $1 + "_import" + i + "." + $2; }));
                         else // Without extension: Append _importN to make it unique
-                            this["import"](json['imports'][i], filename+"_import"+i);
+                            this["import"](json['imports'][i], filename + "_import" + i);
                 }
                 if (resetRoot) // Reset import root override when all imports are done
                     this.importRoot = null;
@@ -4742,18 +4748,18 @@
                 propagateSyntax(json);
             var base = this.ptr;
             if (json['options'])
-                Object.keys(json['options']).forEach(function(key) {
+                Object.keys(json['options']).forEach(function (key) {
                     base.options[key] = json['options'][key];
                 });
             if (json['messages'])
                 this.create(json['messages']),
-                this.ptr = base;
+                    this.ptr = base;
             if (json['enums'])
                 this.create(json['enums']),
-                this.ptr = base;
+                    this.ptr = base;
             if (json['services'])
                 this.create(json['services']),
-                this.ptr = base;
+                    this.ptr = base;
             if (json['extends'])
                 this.create(json['extends']);
 
@@ -4766,7 +4772,7 @@
          * @returns {!ProtoBuf.Builder} this
          * @expose
          */
-        BuilderPrototype.resolveAll = function() {
+        BuilderPrototype.resolveAll = function () {
             // Resolve all reflected objects
             var res;
             if (this.ptr == null || typeof this.ptr.type === 'object')
@@ -4774,7 +4780,7 @@
 
             if (this.ptr instanceof Reflect.Namespace) { // Resolve children
 
-                this.ptr.children.forEach(function(child) {
+                this.ptr.children.forEach(function (child) {
                     this.ptr = child;
                     this.resolveAll();
                 }, this);
@@ -4783,10 +4789,10 @@
 
                 if (!Lang.TYPE.test(this.ptr.type)) {
                     if (!Lang.TYPEREF.test(this.ptr.type))
-                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
+                        throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                     res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                     if (!res)
-                        throw Error("unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
+                        throw Error("unresolvable type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                     this.ptr.resolvedType = res;
                     if (res instanceof Reflect.Enum) {
                         this.ptr.type = ProtoBuf.TYPES["enum"];
@@ -4796,7 +4802,7 @@
                     else if (res instanceof Reflect.Message)
                         this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];
                     else
-                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);
+                        throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
                 } else
                     this.ptr.type = ProtoBuf.TYPES[this.ptr.type];
 
@@ -4804,18 +4810,18 @@
                 // (i.e., no enums or messages), so we don't need to resolve against the current namespace.
                 if (this.ptr.map) {
                     if (!Lang.TYPE.test(this.ptr.keyType))
-                        throw Error("illegal key type for map field in "+this.ptr.toString(true)+": "+this.ptr.keyType);
+                        throw Error("illegal key type for map field in " + this.ptr.toString(true) + ": " + this.ptr.keyType);
                     this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
                 }
 
                 // If it's a repeated and packable field then proto3 mandates it should be packed by
                 // default
                 if (
-                  this.ptr.syntax === 'proto3' &&
-                  this.ptr.repeated && this.ptr.options.packed === undefined &&
-                  ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.ptr.type.wireType) !== -1
+                    this.ptr.syntax === 'proto3' &&
+                    this.ptr.repeated && this.ptr.options.packed === undefined &&
+                    ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.ptr.type.wireType) !== -1
                 ) {
-                  this.ptr.options.packed = true;
+                    this.ptr.options.packed = true;
                 }
 
             } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
@@ -4823,21 +4829,21 @@
                 if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
                     res = this.ptr.parent.resolve(this.ptr.requestName, true);
                     if (!res || !(res instanceof ProtoBuf.Reflect.Message))
-                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);
+                        throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.requestName);
                     this.ptr.resolvedRequestType = res;
                     res = this.ptr.parent.resolve(this.ptr.responseName, true);
                     if (!res || !(res instanceof ProtoBuf.Reflect.Message))
-                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);
+                        throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.responseName);
                     this.ptr.resolvedResponseType = res;
                 } else // Should not happen as nothing else is implemented
-                    throw Error("illegal service type in "+this.ptr.toString(true));
+                    throw Error("illegal service type in " + this.ptr.toString(true));
 
             } else if (
                 !(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
                 !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
                 !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
             )
-                throw Error("illegal object in namespace: "+typeof(this.ptr)+": "+this.ptr);
+                throw Error("illegal object in namespace: " + typeof (this.ptr) + ": " + this.ptr);
 
             return this.reset();
         };
@@ -4850,19 +4856,19 @@
          * @throws {Error} If a type could not be resolved
          * @expose
          */
-        BuilderPrototype.build = function(path) {
+        BuilderPrototype.build = function (path) {
             this.reset();
             if (!this.resolved)
                 this.resolveAll(),
-                this.resolved = true,
-                this.result = null; // Require re-build
+                    this.resolved = true,
+                    this.result = null; // Require re-build
             if (this.result === null) // (Re-)Build
                 this.result = this.ns.build();
             if (!path)
                 return this.result;
             var part = typeof path === 'string' ? path.split(".") : path,
                 ptr = this.result; // Build namespace pointer (no hasChild etc.)
-            for (var i=0; i<part.length; i++)
+            for (var i = 0; i < part.length; i++)
                 if (ptr[part[i]])
                     ptr = ptr[part[i]];
                 else {
@@ -4878,7 +4884,7 @@
          * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
          * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
          */
-        BuilderPrototype.lookup = function(path, excludeNonNamespace) {
+        BuilderPrototype.lookup = function (path, excludeNonNamespace) {
             return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
         };
 
@@ -4887,7 +4893,7 @@
          * @return {string} String representation as of "Builder"
          * @expose
          */
-        BuilderPrototype.toString = function() {
+        BuilderPrototype.toString = function () {
             return "Builder";
         };
 
@@ -4897,17 +4903,17 @@
         /**
          * @alias ProtoBuf.Builder.Message
          */
-        Builder.Message = function() {};
+        Builder.Message = function () { };
 
         /**
          * @alias ProtoBuf.Builder.Enum
          */
-        Builder.Enum = function() {};
+        Builder.Enum = function () { };
 
         /**
          * @alias ProtoBuf.Builder.Message
          */
-        Builder.Service = function() {};
+        Builder.Service = function () { };
 
         return Builder;
 
@@ -4917,7 +4923,7 @@
      * @alias ProtoBuf.Map
      * @expose
      */
-    ProtoBuf.Map = (function(ProtoBuf, Reflect) {
+    ProtoBuf.Map = (function (ProtoBuf, Reflect) {
         "use strict";
 
         /**
@@ -4931,7 +4937,7 @@
          * @param {Object.<string,*>=} contents Initial contents
          * @constructor
          */
-        var Map = function(field, contents) {
+        var Map = function (field, contents) {
             if (!field.map)
                 throw Error("field is not a map");
 
@@ -4973,7 +4979,7 @@
              * Returns the number of elements in the map.
              */
             Object.defineProperty(this, "size", {
-                get: function() { return Object.keys(this.map).length; }
+                get: function () { return Object.keys(this.map).length; }
             });
 
             // Fill initial contents from a raw object.
@@ -4999,7 +5005,7 @@
         function arrayIterator(arr) {
             var idx = 0;
             return {
-                next: function() {
+                next: function () {
                     if (idx < arr.length)
                         return { done: false, value: arr[idx++] };
                     return { done: true };
@@ -5010,7 +5016,7 @@
         /**
          * Clears the map.
          */
-        MapPrototype.clear = function() {
+        MapPrototype.clear = function () {
             this.map = {};
         };
 
@@ -5018,7 +5024,7 @@
          * Deletes a particular key from the map.
          * @returns {boolean} Whether any entry with this key was deleted.
          */
-        MapPrototype["delete"] = function(key) {
+        MapPrototype["delete"] = function (key) {
             var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
             var hadKey = keyValue in this.map;
             delete this.map[keyValue];
@@ -5029,11 +5035,11 @@
          * Returns an iterator over [key, value] pairs in the map.
          * @returns {Object} The iterator
          */
-        MapPrototype.entries = function() {
+        MapPrototype.entries = function () {
             var entries = [];
             var strKeys = Object.keys(this.map);
             for (var i = 0, entry; i < strKeys.length; i++)
-                entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);
+                entries.push([(entry = this.map[strKeys[i]]).key, entry.value]);
             return arrayIterator(entries);
         };
 
@@ -5041,7 +5047,7 @@
          * Returns an iterator over keys in the map.
          * @returns {Object} The iterator
          */
-        MapPrototype.keys = function() {
+        MapPrototype.keys = function () {
             var keys = [];
             var strKeys = Object.keys(this.map);
             for (var i = 0; i < strKeys.length; i++)
@@ -5053,7 +5059,7 @@
          * Returns an iterator over values in the map.
          * @returns {!Object} The iterator
          */
-        MapPrototype.values = function() {
+        MapPrototype.values = function () {
             var values = [];
             var strKeys = Object.keys(this.map);
             for (var i = 0; i < strKeys.length; i++)
@@ -5066,10 +5072,10 @@
          * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
          * @param {Object=} thisArg The `this` value for the callback
          */
-        MapPrototype.forEach = function(cb, thisArg) {
+        MapPrototype.forEach = function (cb, thisArg) {
             var strKeys = Object.keys(this.map);
             for (var i = 0, entry; i < strKeys.length; i++)
-                cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);
+                cb.call(thisArg, (entry = this.map[strKeys[i]]).value, entry.key, this);
         };
 
         /**
@@ -5078,7 +5084,7 @@
          * @param {*} value The value
          * @returns {!ProtoBuf.Map} The map instance
          */
-        MapPrototype.set = function(key, value) {
+        MapPrototype.set = function (key, value) {
             var keyValue = this.keyElem.verifyValue(key);
             var valValue = this.valueElem.verifyValue(value);
             this.map[this.keyElem.valueToString(keyValue)] =
@@ -5091,7 +5097,7 @@
          * @param {*} key The key
          * @returns {*|undefined} The value, or `undefined` if key not present
          */
-        MapPrototype.get = function(key) {
+        MapPrototype.get = function (key) {
             var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
             if (!(keyValue in this.map))
                 return undefined;
@@ -5103,7 +5109,7 @@
          * @param {*} key The key
          * @returns {boolean} `true` if the key is present
          */
-        MapPrototype.has = function(key) {
+        MapPrototype.has = function (key) {
             var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
             return (keyValue in this.map);
         };
@@ -5121,10 +5127,10 @@
      * @throws {Error} If the definition cannot be parsed or built
      * @expose
      */
-    ProtoBuf.loadProto = function(proto, builder, filename) {
+    ProtoBuf.loadProto = function (proto, builder, filename) {
         if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
             filename = builder,
-            builder = undefined;
+                builder = undefined;
         return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
     };
 
@@ -5152,14 +5158,14 @@
      *   request has failed), else undefined
      * @expose
      */
-    ProtoBuf.loadProtoFile = function(filename, callback, builder) {
+    ProtoBuf.loadProtoFile = function (filename, callback, builder) {
         if (callback && typeof callback === 'object')
             builder = callback,
-            callback = null;
+                callback = null;
         else if (!callback || typeof callback !== 'function')
             callback = null;
         if (callback)
-            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
+            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
                 if (contents === null) {
                     callback(Error("Failed to fetch file"));
                     return;
@@ -5170,7 +5176,7 @@
                     callback(e);
                 }
             });
-        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
+        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"] + "/" + filename["file"] : filename);
         return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
     };
 
@@ -5196,7 +5202,7 @@
      * @return {!ProtoBuf.Builder} Builder
      * @expose
      */
-    ProtoBuf.newBuilder = function(options) {
+    ProtoBuf.newBuilder = function (options) {
         options = options || {};
         if (typeof options['convertFieldsToCamelCase'] === 'undefined')
             options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
@@ -5214,10 +5220,10 @@
      * @throws {Error} If the definition cannot be parsed or built
      * @expose
      */
-    ProtoBuf.loadJson = function(json, builder, filename) {
+    ProtoBuf.loadJson = function (json, builder, filename) {
         if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
             filename = builder,
-            builder = null;
+                builder = null;
         if (!builder || typeof builder !== 'object')
             builder = ProtoBuf.newBuilder();
         if (typeof json === 'string')
@@ -5239,14 +5245,14 @@
      *   request has failed), else undefined
      * @expose
      */
-    ProtoBuf.loadJsonFile = function(filename, callback, builder) {
+    ProtoBuf.loadJsonFile = function (filename, callback, builder) {
         if (callback && typeof callback === 'object')
             builder = callback,
-            callback = null;
+                callback = null;
         else if (!callback || typeof callback !== 'function')
             callback = null;
         if (callback)
-            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
+            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
                 if (contents === null) {
                     callback(Error("Failed to fetch file"));
                     return;
@@ -5257,7 +5263,7 @@
                     callback(e);
                 }
             });
-        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
+        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"] + "/" + filename["file"] : filename);
         return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
     };
 
